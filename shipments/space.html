<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shipment Space - Airway Bills</title>
    <base href="/">
    <link rel="stylesheet" href="/styles.css">
    <script type="module" src="/js/themes.js"></script>
    <style>
        body {
            margin: 0;
            padding: 2px;
            font-family: 'MS Sans Serif', 'Arial', sans-serif;
            background: #008080;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.02) 2px, rgba(0,0,0,0.02) 4px);
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #C0C0C0;
            padding: 8px;
            border: 2px outset #C0C0C0;
            display: flex;
            gap: 8px;
        }
        .main-content {
            flex: 1;
            min-width: 0;
        }
        .participants-sidebar {
            width: 300px;
            background: #C0C0C0;
            border: 2px inset #C0C0C0;
            padding: 8px;
            display: flex;
            flex-direction: column;
        }
        .space-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px inset #C0C0C0;
        }
        .space-header h1 {
            margin: 0;
            color: #000000;
            font-size: 16px;
            font-weight: bold;
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }
        .space-id {
            font-size: 12px;
            color: #000000;
            margin: 5px 0;
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }
        .awb-number {
            font-size: 16px;
            font-weight: bold;
            color: #000000;
            margin: 10px 0;
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }
        .status-badge {
            padding: 4px 12px;
            border: 2px inset #C0C0C0;
            font-size: 11px;
            font-weight: normal;
            text-transform: uppercase;
            background: #C0C0C0;
            color: #000000;
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }
        .status-active { background: #E0FFE0; color: #000000; }
        .status-cancelled { background: #FFE0E0; color: #000000; }
        .status-shared { background: #FFFFE0; color: #000000; }
        .status-pending { background: #FFFFE0; color: #000000; }
        .status-in-transit { background: #E0E0FF; color: #000000; }
        .action-buttons {
            margin-top: 20px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .btn {
            padding: 4px 12px;
            border: 2px solid #808080;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            background: #D4D4D4;
            color: #000000;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            white-space: nowrap;
        }
        .btn-primary {
            background: #C0C0C0;
            color: #000000;
        }
        .btn-success {
            background: #C0C0C0;
            color: #000000;
        }
        .btn-warning {
            background: #C0C0C0;
            color: #000000;
        }
        .btn-danger {
            background: #C0C0C0;
            color: #000000;
        }
        .btn-secondary {
            background: #C0C0C0;
            color: #000000;
        }
        .btn:hover {
            background: #E8E8E8;
        }
        .btn:active {
            border: 2px solid #606060;
            background: #B0B0B0;
        }
        .info-section {
            margin: 20px 0;
            padding: 8px;
            background: white;
            border: 2px inset #C0C0C0;
        }
        .info-section h2 {
            margin-top: 0;
            color: #000000;
            font-size: 14px;
            font-weight: bold;
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }
        .participants-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 8px;
            flex: 1;
            overflow-y: auto;
        }
        .role-section {
            border: 2px inset #C0C0C0;
            padding: 8px;
            background: white;
        }
        .role-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid #C0C0C0;
        }
        .role-section-title {
            font-size: 12px;
            font-weight: bold;
            color: #000000;
        }
        .role-participants {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 8px;
        }
        .role-add-section {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .role-add-select {
            width: 100%;
            padding: 2px 4px;
            border: 2px inset #C0C0C0;
            font-size: 10px;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            background: white;
        }
        .role-add-btn {
            padding: 2px 8px;
            border: 2px outset #C0C0C0;
            background: #C0C0C0;
            color: #000000;
            font-size: 10px;
            font-weight: normal;
            cursor: pointer;
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }
        .role-add-btn:hover {
            background: #E8E8E8;
        }
        .role-add-btn:active {
            border: 2px inset #C0C0C0;
            background: #808080;
        }
        .participant-badge {
            background: #C0C0C0;
            color: #000000;
            padding: 6px 8px;
            border: 2px inset #C0C0C0;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            width: 100%;
            box-sizing: border-box;
        }
        .participant-info {
            flex: 1;
            min-width: 0;
        }
        .participant-remove {
            background: #808080;
            border: 2px outset #C0C0C0;
            color: #000000;
            width: 18px;
            height: 18px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }
        .participant-remove:hover {
            background: #A0A0A0;
        }
        .participant-remove:active {
            border: 2px inset #C0C0C0;
            background: #606060;
        }
        .participant-leave {
            background: #C0C0C0;
            border: 2px outset #C0C0C0;
            color: #000000;
            padding: 2px 6px;
            cursor: pointer;
            font-size: 10px;
            font-weight: normal;
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }
        .participant-leave:hover {
            background: #E8E8E8;
        }
        .participant-leave:active {
            border: 2px inset #C0C0C0;
            background: #808080;
        }
        .pdf-section {
            margin: 20px 0;
            padding: 8px;
            background: white;
            border: 2px inset #C0C0C0;
        }
        .pdf-section h2 {
            margin-top: 0;
            color: #000000;
            font-size: 14px;
            font-weight: bold;
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }
        .pdf-section p {
            color: #000000;
            font-size: 11px;
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }
        .restricted-section {
            margin: 20px 0;
            padding: 8px;
            background: white;
            border: 2px inset #C0C0C0;
        }
        .restricted-section p {
            margin: 0;
            color: #000000;
            font-size: 11px;
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="space-header">
                <div>
                    <h1>Shipment Space</h1>
                    <div class="awb-number" id="awbDisplay" style="display: none;"></div>
                    <div class="space-id" id="spaceIdDisplay">Loading...</div>
                </div>
                <div>
                    <span class="status-badge" id="statusBadge">Loading...</span>
                </div>
            </div>

            <div id="agentSection" style="display: none;">
                <div class="action-buttons">
                    <button class="btn btn-primary" id="createAWBBtn">Create AWB</button>
                    <button class="btn btn-success" id="shareAWBBtn" style="display: none;">Share AWB with Participants</button>
                    <button class="btn btn-warning" id="cancelBtn">Cancel Shipment</button>
                    <button class="btn btn-danger" id="deleteBtn" style="display: none;">Delete Shipment</button>
                </div>
            </div>

            <div id="pdfSection" class="pdf-section" style="display: none;">
                <h2>AWB Document</h2>
                <p id="pdfStatus">PDF is available for download.</p>
                <button class="btn btn-success" id="downloadPDFBtn">Download AWB PDF</button>
            </div>

            <div id="restrictedSection" class="restricted-section" style="display: none;">
                <p><strong>Access Restricted:</strong> Only the Issuing Carrier Agent can view and modify AWB form data. You can view and download the AWB PDF if it has been shared.</p>
            </div>
        </div>

        <div class="participants-sidebar">
            <div style="margin-bottom: 8px;">
                <h2 style="margin: 0 0 8px 0; font-size: 14px; font-weight: bold;">Participants</h2>
            </div>
            <div id="participantsList" style="display: flex; flex-direction: column; gap: 12px; flex: 1; overflow-y: auto;">
                <!-- Role sections will be dynamically generated here -->
            </div>
        </div>
    </div>

    <script type="module" src="../js/api.js"></script>
    <script src="../models/user.js"></script>
    <script src="../models/shipment.js"></script>
    <script src="../js/roles.js"></script>
    <script type="module" src="../js/auth.js"></script>
    <script type="module" src="../js/shipments.js"></script>

    <script>
        // Wait for auth functions to be available (modules load asynchronously)
        (async function() {
            // Wait for auth functions to be available
            let attempts = 0;
            while ((typeof isAuthenticated === 'undefined' || typeof getCurrentUser === 'undefined' || typeof getCurrentUserAsync === 'undefined') && attempts < 50) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            // Wait for API to be ready before calling getCurrentUser
            if (!window.usersAPI) {
                // Wait for apiReady event (max 5 seconds)
                await new Promise((resolve) => {
                    // Check if already available
                    if (window.usersAPI) {
                        resolve();
                        return;
                    }
                    
                    // Listen for apiReady event
                    const handler = () => {
                        if (window.usersAPI) {
                            resolve();
                        }
                    };
                    window.addEventListener('apiReady', handler, { once: true });
                    
                    // Also check periodically in case event already fired
                    let checks = 0;
                    const checkInterval = setInterval(() => {
                        checks++;
                        if (window.usersAPI) {
                            window.removeEventListener('apiReady', handler);
                            clearInterval(checkInterval);
                            resolve();
                        } else if (checks >= 50) { // 5 seconds (50 * 100ms)
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 100);
                });
            }
            
            // Give auth.js module more time to set its internal usersAPI variable
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Check authentication with error handling
            let user = null;
            try {
                // Try to get user - use window.usersAPI directly if module isn't ready
                if (window.usersAPI) {
                    try {
                        // Try direct API call first (most reliable)
                        if (window.usersAPI.getCurrent) {
                            try {
                                user = await window.usersAPI.getCurrent();
                            } catch (apiError) {
                                console.warn('API call failed:', apiError.message);
                                // If it's not a 401 (unauthorized), try using cached data
                                if (!apiError.message.includes('401') && !apiError.message.includes('Unauthorized')) {
                                    const cachedUser = getCurrentUser();
                                    if (cachedUser) {
                                        console.log('Using cached user due to API error');
                                        user = cachedUser;
                                    }
                                }
                            }
                        }
                        
                        // If direct call didn't work, try async function
                        if (!user && typeof getCurrentUserAsync !== 'undefined') {
                            try {
                                user = await getCurrentUserAsync();
                            } catch (asyncError) {
                                console.warn('getCurrentUserAsync failed:', asyncError.message);
                                const cachedUser = getCurrentUser();
                                if (cachedUser) {
                                    console.log('Using cached user after async function failed');
                                    user = cachedUser;
                                }
                            }
                        }
                    } catch (error) {
                        console.warn('Error getting user from API, trying sync version:', error);
                        await new Promise(resolve => setTimeout(resolve, 300));
                        user = getCurrentUser();
                    }
                } else {
                    await new Promise(resolve => setTimeout(resolve, 300));
                    user = getCurrentUser();
                }
                
                // If still no user, check localStorage for auth data
                if (!user) {
                    const authData = localStorage.getItem('awb_auth');
                    if (authData) {
                        try {
                            const auth = JSON.parse(authData);
                            if (auth.isAuthenticated && auth.userId) {
                                const cachedUser = getCurrentUser();
                                if (cachedUser && cachedUser.id === auth.userId) {
                                    console.log('Using cached user from localStorage auth data');
                                    user = cachedUser;
                                }
                            }
                        } catch (e) {
                            // Invalid auth data
                        }
                    }
                }
                
                // Only redirect if we truly have no user
                if (!user) {
                    console.error('No user found after authentication check');
                    window.location.href = '../login.html';
                    return;
                }
            } catch (error) {
                console.error('Authentication error:', error);
                window.location.href = '../login.html';
                return;
            }
            
            // Continue with page setup after authentication check
            setupPage(user);
        })();
        
        function setupPage(user) {
            // Get spaceId from URL
            const urlParams = new URLSearchParams(window.location.search);
            const spaceId = urlParams.get('spaceId');
            
            if (!spaceId) {
                alert('No shipment space ID provided.');
                goBack();
                return;
            }

            let currentShipment = null;

        // Load shipment space
        async function loadSpace() {
            try {
                currentShipment = await getShipmentBySpaceId(spaceId);
                
                if (!currentShipment) {
                    alert('Shipment space not found.');
                    goBack();
                    return;
                }

                // Check if user has access (admins can access all shipments)
                const isAdmin = user.role === 'admin';
                const participants = currentShipment.participants || [];
                const hasAccess = isAdmin || 
                                currentShipment.createdBy === user.id || 
                                participants.some(p => p.userId === user.id);
                
                if (!hasAccess) {
                    console.error('Access denied:', {
                        userId: user.id,
                        createdBy: currentShipment.createdBy,
                        participants: participants.map(p => p.userId),
                        isAdmin: isAdmin
                    });
                    alert('You do not have access to this shipment space.');
                    goBack();
                    return;
                }

                // Display space info - AWB number as primary, Space ID as secondary
            if (currentShipment.awbNumber) {
                document.getElementById('awbDisplay').textContent = `AWB: ${currentShipment.awbNumber}`;
                document.getElementById('awbDisplay').style.display = 'block';
                document.getElementById('spaceIdDisplay').textContent = `Space ID: ${currentShipment.spaceId}`;
            } else {
                // If no AWB yet, show Space ID as primary
                document.getElementById('awbDisplay').style.display = 'none';
                document.getElementById('spaceIdDisplay').textContent = `Space ID: ${currentShipment.spaceId}`;
                document.getElementById('spaceIdDisplay').style.fontSize = '16px';
                document.getElementById('spaceIdDisplay').style.fontWeight = 'bold';
                document.getElementById('spaceIdDisplay').style.color = '#000000';
            }

            // Status badge
            const statusBadge = document.getElementById('statusBadge');
            let statusText = currentShipment.status;
            if (currentShipment.isShared && currentShipment.status === 'active') {
                statusText = 'Shared';
                statusBadge.className = 'status-badge status-shared';
            } else {
                statusBadge.className = `status-badge status-${currentShipment.status}`;
            }
            statusBadge.textContent = statusText;

            // Show/hide sections based on role
            const isAgent = user.role === 'issuing-carrier-agent';
            // isAdmin already declared above
            const isCancelled = currentShipment.status === 'cancelled';
            
            if (isAgent || isAdmin) {
                document.getElementById('agentSection').style.display = 'block';
                
                // Show Create AWB button only for agents (not admins) and only if AWB not created yet
                if (isAgent && !currentShipment.awbNumber) {
                    document.getElementById('createAWBBtn').style.display = 'block';
                } else {
                    document.getElementById('createAWBBtn').style.display = 'none';
                }
                
                // Show Share button only for agents (not admins) and only if AWB exists and not shared yet
                if (isAgent && currentShipment.awbNumber && !currentShipment.isShared) {
                    document.getElementById('shareAWBBtn').style.display = 'block';
                } else {
                    document.getElementById('shareAWBBtn').style.display = 'none';
                }
                
                // Show delete button for agents and admins (except for deleted or in-transit shipments)
                const canDelete = (isAgent || isAdmin) && 
                                  currentShipment.status !== 'deleted' && 
                                  currentShipment.status !== 'in-transit';
                if (canDelete) {
                    document.getElementById('deleteBtn').style.display = 'block';
                } else {
                    document.getElementById('deleteBtn').style.display = 'none';
                }
                
                // Update cancel button text if cancelled
                if (isCancelled && isAgent) {
                    document.getElementById('cancelBtn').textContent = 'Uncancel Shipment';
                }
                
                // Show cancel/uncancel button only for agents (not admins)
                if (!isAgent) {
                    document.getElementById('cancelBtn').style.display = 'none';
                }
            } else {
                // Non-agents see restricted message
                document.getElementById('restrictedSection').style.display = 'block';
            }

            // Show PDF section if available and shared (or if agent or admin)
            if (currentShipment.pdfBase64 && (isAgent || isAdmin || currentShipment.isShared)) {
                document.getElementById('pdfSection').style.display = 'block';
            }

            // Load participants
            loadParticipants();
            
            // Setup add participant functionality if user is creator or admin/agent
            const isCreator = currentShipment.createdBy === user.id;
            if (isCreator || isAgent || isAdmin) {
                setupAddParticipant();
            }

            // Disable actions if cancelled (except for agent or admin)
            if (isCancelled && !isAgent && !isAdmin) {
                // Non-agents and non-admins can't do anything with cancelled shipments
                document.getElementById('restrictedSection').innerHTML = '<p><strong>Cancelled:</strong> This shipment has been cancelled and is no longer accessible.</p>';
            }
            
            // Add Edit button for admins if AWB exists
            if (isAdmin && currentShipment.awbNumber) {
                const agentSection = document.getElementById('agentSection');
                if (agentSection) {
                    // Check if edit button already exists
                    let editBtn = document.getElementById('editAWBBtn');
                    if (!editBtn) {
                        editBtn = document.createElement('button');
                        editBtn.id = 'editAWBBtn';
                        editBtn.className = 'btn-primary';
                        editBtn.textContent = 'Edit AWB';
                        editBtn.style.marginTop = '10px';
                        editBtn.addEventListener('click', function() {
                            // Navigate to edit page
                            if (window.parent && window.parent !== window) {
                                window.parent.document.getElementById('contentFrame').src = `shipments/edit.html?awb=${currentShipment.awbNumber}`;
                            } else {
                                window.location.href = `edit.html?awb=${currentShipment.awbNumber}`;
                            }
                        });
                        agentSection.appendChild(editBtn);
                    }
                }
            }
            } catch (error) {
                console.error('Error loading shipment space:', error);
                alert('Error loading shipment space: ' + (error.message || 'Unknown error'));
                goBack();
                return;
            }
        }

        async function loadParticipants() {
            const participants = currentShipment.participants || [];
            const list = document.getElementById('participantsList');
            
            // Check if ROLES and ROLE_LABELS are available
            if (typeof ROLES === 'undefined' || typeof ROLE_LABELS === 'undefined') {
                list.innerHTML = '<p>Roles not loaded. Please refresh the page.</p>';
                return;
            }
            
            // Check if current user can add/remove participants (creator, admin, or agent)
            const isCreator = currentShipment.createdBy === user.id;
            const isAdmin = user.role === 'admin';
            const isAgent = user.role === 'issuing-carrier-agent';
            const canManage = isCreator || isAdmin || isAgent;
            
            // Define the 4 addable roles
            const addableRoles = [
                { role: ROLES.SHIPPER, label: ROLE_LABELS[ROLES.SHIPPER] },
                { role: ROLES.CONSIGNEE, label: ROLE_LABELS[ROLES.CONSIGNEE] },
                { role: ROLES.CUSTOMS_BROKER, label: ROLE_LABELS[ROLES.CUSTOMS_BROKER] },
                { role: ROLES.COURIER, label: ROLE_LABELS[ROLES.COURIER] }
            ];
            
            // Group participants by role
            const participantsByRole = {};
            addableRoles.forEach(r => {
                participantsByRole[r.role] = [];
            });
            
            // Fetch participant user data and group by role
            const participantPromises = participants.map(async (p) => {
                try {
                    let participantUser = null;
                    if (typeof window !== 'undefined' && typeof window.getUserById === 'function') {
                        participantUser = await window.getUserById(p.userId);
                    }
                    return {
                        ...p,
                        user: participantUser
                    };
                } catch (error) {
                    console.error('Error loading participant:', p.userId, error);
                    return {
                        ...p,
                        user: null
                    };
                }
            });
            
            const participantsWithUsers = await Promise.all(participantPromises);
            
            // Group by role
            participantsWithUsers.forEach(p => {
                if (participantsByRole[p.role]) {
                    participantsByRole[p.role].push(p);
                }
            });
            
            // Build HTML for each role section
            let html = '';
            
            for (const roleInfo of addableRoles) {
                const roleParticipants = participantsByRole[roleInfo.role] || [];
                const roleId = roleInfo.role.replace(/-/g, '_');
                
                html += `<div class="role-section" data-role="${roleInfo.role}">`;
                html += `<div class="role-section-header">`;
                html += `<span class="role-section-title">${escapeHtml(roleInfo.label)}</span>`;
                html += `<span style="font-size: 10px; color: #666;">(${roleParticipants.length})</span>`;
                html += `</div>`;
                
                // Participants list
                html += `<div class="role-participants" id="participants_${roleId}">`;
                if (roleParticipants.length === 0) {
                    html += `<p style="font-size: 10px; color: #666; margin: 0;">No ${roleInfo.label}s</p>`;
                } else {
                    roleParticipants.forEach(p => {
                        const name = p.user ? p.user.name : 'Unknown User';
                        const isSelf = p.userId === user.id;
                        
                        let actionButton = '';
                        if (isSelf) {
                            actionButton = `<button class="participant-leave" onclick="leaveSpace()" title="Leave this space">Leave</button>`;
                        } else if (canManage) {
                            actionButton = `<button class="participant-remove" onclick="removeParticipant('${p.userId}')" title="Remove participant">Ã—</button>`;
                        }
                        
                        html += `<div class="participant-badge">`;
                        html += `<span class="participant-info">${escapeHtml(name)}</span>`;
                        html += actionButton;
                        html += `</div>`;
                    });
                }
                html += `</div>`;
                
                // Add section (only if can manage)
                if (canManage) {
                    html += `<div class="role-add-section">`;
                    html += `<select id="userSelect_${roleId}" class="role-add-select">`;
                    html += `<option value="">-- Add ${roleInfo.label} --</option>`;
                    html += `</select>`;
                    html += `<button class="role-add-btn" onclick="addParticipantForRole('${roleInfo.role}')">Add</button>`;
                    html += `</div>`;
                }
                
                html += `</div>`;
            }
            
            list.innerHTML = html;
            
            // Load users for each role dropdown
            if (canManage) {
                await loadUsersForAllRoles();
            }
        }
        
        async function loadUsersForAllRoles() {
            // Check if ROLES and ROLE_LABELS are available
            if (typeof ROLES === 'undefined' || typeof ROLE_LABELS === 'undefined') {
                console.error('Roles not available');
                return;
            }
            
            // Wait for getAllUsers to be available
            let attempts = 0;
            while (typeof getAllUsers === 'undefined' && attempts < 50) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            if (typeof getAllUsers === 'undefined') {
                console.error('getAllUsers not available');
                return;
            }
            
            const allUsers = await getAllUsers();
            
            if (!Array.isArray(allUsers)) {
                console.error('getAllUsers did not return an array:', allUsers);
                return;
            }
            
            // Get current participants to exclude them
            const currentParticipants = currentShipment.participants || [];
            const participantIds = currentParticipants.map(p => p.userId);
            
            // Define the 4 addable roles
            const addableRoles = [
                ROLES.SHIPPER,
                ROLES.CONSIGNEE,
                ROLES.CUSTOMS_BROKER,
                ROLES.COURIER
            ];
            
            // Populate each role's dropdown
            for (const role of addableRoles) {
                const roleId = role.replace(/-/g, '_');
                const select = document.getElementById(`userSelect_${roleId}`);
                
                if (!select) continue;
                
                // Filter users by role and exclude existing participants
                const filteredUsers = allUsers.filter(u => 
                    u.role === role && 
                    u.isActive !== false && 
                    !participantIds.includes(u.id)
                );
                
                // Clear and populate dropdown
                select.innerHTML = '<option value="">-- Add ' + (ROLE_LABELS[role] || role) + ' --</option>';
                if (filteredUsers.length === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = '-- No Users Available --';
                    select.appendChild(option);
                } else {
                    filteredUsers.forEach(user => {
                        const option = document.createElement('option');
                        option.value = user.id;
                        option.textContent = `${user.name}${user.company ? ' - ' + user.company : ''} (${user.email})`;
                        select.appendChild(option);
                    });
                }
            }
        }
        
        async function addParticipantForRole(role) {
            const roleId = role.replace(/-/g, '_');
            const select = document.getElementById(`userSelect_${roleId}`);
            
            if (!select || !select.value) {
                alert('Please select a user to add.');
                return;
            }
            
            const userId = select.value;
            
            try {
                const selectedUser = await getUserById(userId);
                if (selectedUser && selectedUser.role === role) {
                    await addParticipantToSpace(selectedUser.id, role, user.id);
                    // Clear the dropdown selection
                    select.value = '';
                    // Reload participants to update all sections (don't reload full space)
                    await loadParticipants();
                } else {
                    alert('Invalid user selected.');
                }
            } catch (error) {
                console.error('Error getting user:', error);
                alert('Error loading user. Please try again.');
            }
        }
        
        // Make function available globally
        window.addParticipantForRole = addParticipantForRole;

        async function removeParticipant(userId) {
            if (!confirm('Are you sure you want to remove this participant from the shipment space?')) {
                return;
            }

            try {
                const SHIPMENTS_STORAGE_KEY = 'awb_shipments';
                
                // Use currentShipment as source of truth to preserve existing participants
                if (!currentShipment) {
                    alert('Shipment not loaded. Please refresh the page.');
                    return;
                }
                
                // Get current participants from currentShipment
                let participants = currentShipment.participants || [];
                
                // Remove the participant
                const originalCount = participants.length;
                participants = participants.filter(p => p.userId !== userId);
                
                if (participants.length === originalCount) {
                    alert('Participant not found in shipment.');
                    return;
                }
                
                console.log('Removing participant:', userId);
                console.log('Remaining participants:', participants);

                // Update currentShipment with the filtered participants
                currentShipment.participants = participants;
                
                // Get shipments array for saving
                let shipments = [];
                if (typeof getAllShipments === 'function') {
                    const result = await getAllShipments();
                    shipments = Array.isArray(result) ? result : [];
                } else {
                    // Fallback to localStorage
                    try {
                        const shipmentsJson = localStorage.getItem(SHIPMENTS_STORAGE_KEY);
                        shipments = shipmentsJson ? JSON.parse(shipmentsJson) : [];
                        if (!Array.isArray(shipments)) {
                            shipments = [];
                        }
                    } catch (e) {
                        console.error('Error reading shipments from localStorage:', e);
                        shipments = [];
                    }
                }
                
                // Update the shipment in the shipments array
                const shipmentIndex = shipments.findIndex(s => s.spaceId === spaceId);
                if (shipmentIndex === -1) {
                    alert('Shipment not found in shipments list.');
                    return;
                }
                
                // Update the shipment with currentShipment's participants (preserving all other data)
                shipments[shipmentIndex].participants = currentShipment.participants;
                
                // Save to localStorage
                localStorage.setItem(SHIPMENTS_STORAGE_KEY, JSON.stringify(shipments));
                
                // Update via API if available
                if (window.shipmentsAPI) {
                    try {
                        // Use currentShipment data to ensure we're sending the complete, up-to-date shipment
                        // The update function expects a single shipment object with spaceId
                        const shipmentToUpdate = {
                            ...shipments[shipmentIndex],
                            spaceId: spaceId, // Ensure spaceId is present
                            participants: currentShipment.participants
                        };
                        await window.shipmentsAPI.update(shipmentToUpdate);
                    } catch (error) {
                        console.warn('Could not update shipment via API:', error);
                    }
                }
                
                alert('Participant removed successfully.');
                // Reload participants to update all role sections
                // Don't call loadSpace() as it will fetch from API which might not be updated yet
                await loadParticipants();
            } catch (error) {
                console.error('Error removing participant:', error);
                alert('Error removing participant. Please try again.');
            }
        }

        // Make function available globally for onclick handlers
        window.removeParticipant = removeParticipant;
        
        // Leave space function (for participants to remove themselves)
        async function leaveSpace() {
            if (!confirm('Are you sure you want to leave this shipment space?')) {
                return;
            }
            
            await removeParticipant(user.id);
        }
        
        // Make function available globally
        window.leaveSpace = leaveSpace;
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Setup add participant functionality (now handled in loadParticipants)
        async function setupAddParticipant() {
            // Functionality is now integrated into loadParticipants()
            // This function is kept for compatibility but does nothing
        }
        
        // Add participant to existing space
        async function addParticipantToSpace(userId, role, invitedBy) {
            try {
                const SHIPMENTS_STORAGE_KEY = 'awb_shipments';
                
                // Use currentShipment as source of truth to preserve existing participants
                if (!currentShipment) {
                    alert('Shipment not loaded. Please refresh the page.');
                    return;
                }
                
                // Check if participant already exists in currentShipment
                const existingParticipants = currentShipment.participants || [];
                const existing = existingParticipants.find(p => p.userId === userId);
                if (existing) {
                    alert('This participant is already added to the space.');
                    return;
                }
                
                // Add new participant to the existing participants list
                const newParticipant = {
                    userId: userId,
                    role: role,
                    invitedAt: new Date().toISOString(),
                    invitedBy: invitedBy
                };
                
                // Update currentShipment with the new participant
                currentShipment.participants = [...existingParticipants, newParticipant];
                
                // Get shipments array for saving
                let shipments = [];
                if (typeof getAllShipments === 'function') {
                    const result = await getAllShipments();
                    shipments = Array.isArray(result) ? result : [];
                } else {
                    // Fallback to localStorage
                    try {
                        const shipmentsJson = localStorage.getItem(SHIPMENTS_STORAGE_KEY);
                        shipments = shipmentsJson ? JSON.parse(shipmentsJson) : [];
                        if (!Array.isArray(shipments)) {
                            shipments = [];
                        }
                    } catch (e) {
                        console.error('Error reading shipments from localStorage:', e);
                        shipments = [];
                    }
                }
                
                // Update the shipment in the shipments array with currentShipment data
                const shipmentIndex = shipments.findIndex(s => s.spaceId === spaceId);
                if (shipmentIndex === -1) {
                    alert('Shipment not found in shipments list.');
                    return;
                }
                
                // Update the shipment with currentShipment's participants (preserving all other data)
                shipments[shipmentIndex].participants = currentShipment.participants;
                
                // Save to localStorage first
                localStorage.setItem(SHIPMENTS_STORAGE_KEY, JSON.stringify(shipments));
                
                // Update via API if available
                if (window.shipmentsAPI) {
                    try {
                        // Use currentShipment data to ensure we're sending the complete, up-to-date shipment
                        // The update function expects a single shipment object with spaceId
                        const shipmentToUpdate = {
                            ...shipments[shipmentIndex],
                            spaceId: spaceId, // Ensure spaceId is present
                            participants: currentShipment.participants
                        };
                        await window.shipmentsAPI.update(shipmentToUpdate);
                    } catch (error) {
                        console.warn('Could not update shipment via API:', error);
                        // Continue even if API update fails - localStorage is saved
                    }
                }
                
                // Reload participants list immediately without full page reload
                // Don't call loadSpace() as it will fetch from API which might not be updated yet
                await loadParticipants();
            } catch (error) {
                console.error('Error adding participant:', error);
                alert('Error adding participant. Please try again.');
            }
        }

        // Button handlers
        document.getElementById('createAWBBtn').addEventListener('click', function() {
            // Store spaceId and redirect to create-awb.html
            sessionStorage.setItem('currentSpaceId', spaceId);
            if (window.parent && window.parent !== window) {
                window.parent.document.getElementById('contentFrame').src = '../create-awb.html?spaceId=' + spaceId;
            } else {
                window.location.href = '../create-awb.html?spaceId=' + spaceId;
            }
        });

        document.getElementById('shareAWBBtn').addEventListener('click', function() {
            if (confirm('Are you sure you want to share this AWB with all participants? They will be able to view and download the PDF.')) {
                const result = shareShipment(spaceId);
                if (result.success) {
                    alert('AWB shared successfully with participants!');
                    loadSpace(); // Reload to update UI
                } else {
                    alert('Error sharing AWB: ' + result.message);
                }
            }
        });

        document.getElementById('cancelBtn').addEventListener('click', function() {
            if (currentShipment.status === 'cancelled') {
                // Uncancel
                if (confirm('Are you sure you want to uncancel this shipment?')) {
                    const result = uncancelShipment(spaceId);
                    if (result.success) {
                        alert('Shipment uncancelled successfully.');
                        loadSpace();
                    } else {
                        alert('Error: ' + result.message);
                    }
                }
            } else {
                // Cancel
                if (confirm('Are you sure you want to cancel this shipment? Participants will no longer be able to access it.')) {
                    const result = cancelShipment(spaceId);
                    if (result.success) {
                        alert('Shipment cancelled successfully.');
                        loadSpace();
                    } else {
                        alert('Error: ' + result.message);
                    }
                }
            }
        });

        document.getElementById('deleteBtn').addEventListener('click', async function() {
            if (confirm('Are you sure you want to permanently delete this shipment space? This action cannot be undone.')) {
                if (confirm('This is your final confirmation. The shipment will be permanently deleted.')) {
                    try {
                        const result = await deleteShipment(spaceId);
                        if (result.success) {
                            alert('Shipment deleted successfully.');
                            goBack();
                        } else {
                            alert('Error: ' + result.message);
                        }
                    } catch (error) {
                        console.error('Error deleting shipment:', error);
                        alert('Error deleting shipment: ' + (error.message || 'Unknown error'));
                    }
                }
            }
        });

        document.getElementById('downloadPDFBtn').addEventListener('click', function() {
            if (!currentShipment.pdfBase64) {
                alert('PDF not available.');
                return;
            }

            try {
                const binaryString = atob(currentShipment.pdfBase64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const blob = new Blob([bytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `AWB-${currentShipment.awbNumber || currentShipment.spaceId}.pdf`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Error downloading PDF:', error);
                alert('Error downloading PDF: ' + error.message);
            }
        });

        function goBack() {
            if (window.parent && window.parent !== window) {
                // In iframe - path is relative to dashboard.html (root directory)
                window.parent.document.getElementById('contentFrame').src = 'shipments/list.html';
            } else {
                // Not in iframe - path is relative to current file (shipments/ directory)
                window.location.href = 'list.html';
            }
        }
        
        // Load space on page load (inside setupPage)
        loadSpace();
        }
    </script>
</body>
</html>
